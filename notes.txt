Bach Ngo Assignment 5

- In the Makefile, under submission-tarball and randall, we add *.c and *.h to make sure our compilation links correctly
- Make the necessary .c and paired .h files of the following files:
these files, when made, simply take some methods and includes from randall.c. .c has the implmentation, .h has the prototypes. When we modularize all these functions, remove the static keyword.
- cpu; where we pu the cpuid.h include and all matching cpu structs and methods
- rand64-sw; where we put all software methods under the comment header and add matching includes
- In rand64-sw.c, in the places where we call abort();, we can replace them with stderr error messages using fprintf and exiting our program with status 1.
- rand64-hw; where we put all hardware methods under the comment header and add matching includes
- mrand; implement init, normal, and fini methods using drand (read up on it)
- implement a checkArguments function in options.c and its protoypes and argument struct in .h: loop through every argument and check if the arg flags are -i or -o or something else(error). You then loop through the aguments and check if they're properly formatted in their options, like -i *input* or -o *output*. If everything's good or our -o Nbytes is 0, we can return properly. This is mostly pulled from the first half of the main function in randall.c. The argument parsing is done using getopt().
- make mrand.c/h files to deal with the mrand64_r option of input. rdrand and the filepath will be handled within main itself. 
- Now, we actually implement the rest of main in randall. We basically use our checkArgs function to see what the input and out of the current options are and parse them as cstrings. We use strcmp to handle this. if output is rdrand, point the given func pointers to hardware. If its mrand48_r, we use the mrand48 functions from mrand. If its a filepath starting with '/', use software. From there, the dealings with the randomization are handled in the given modularized functions within the *rand* files, so we just have to process the output. We use output.h's functions to do this:
- writebytes and tostdout are already given in the main function, we just copy and paste them and go on to write writeToN, which actually allocates a memory buffer for the randomized integers generated by the rand64 func pointer that we pass through. We basically just loop through the allocated buffer for every sized unsigned long long and copy the memory of the randomly generated bytes to the buffer, one by one until we hit some desired length given by the -o flag. We also have to write this allocated buffer to stdout. Of course, free the allocated memory for every iteration. Later note: I didn't see we needed to use write(), but use that to find out how many bytes were actually written and to actually write it to stdout.
- going back to main in randall, we basically just initialize our random generating medium, then check to see if our output is to stdio or not. we also check the option to the -o flag to see if we are given a positive integer or not. If everything's valid, then we use our output.c functions and return. 
- Since everything was done in emacs, I had way too many typos(definitely some in this file) and some missing includes so I'd probably run make just to see what kind of errors there were.
- Fix an error where getopt() permutes the order of argv, so when we try to parse where nbytes is in the arguments, there is an error. We just move the nbytes checking before we call getopt. You could also make a copy of argv before you call getopt and use that to parse for nbytes, but moving the chunks works fine.
- Fix an error where getopt returns -1 and I check it incorrectly in the while loop so it incorrectly parses the -i option when -i is the first option before -o. Also, I forgot the : at the end of the optstring in getopt so sometimes the -o option would return a null argument. 


Below are some time testing benchmarks:

time dd if=/dev/urandom ibs=8192 obs=8192 count=16384 >/dev/null

16384+0 records in
16384+0 records out
134217728 bytes (134 MB, 128 MiB) copied, 0.903535 s, 149 MB/s

real	0m0.908s
user	0m0.015s
sys	0m0.888s

time ./randall -i /dev/urandom 133562368 | cat >/dev/null

real	0m4.069s
user	0m3.999s
sys	0m0.241s

time ./randall 133562368 >/dev/null

real	0m4.256s
user	0m4.114s
sys	0m0.071s

time ./randall 133562368 >rand.data

real	0m5.851s
user	0m4.134s
sys	0m0.110s

time ./randall -i /dev/urandom -o 133562369 133562368 > /dev/null

real	0m1.373s
user	0m0.396s
sys	0m0.951s

time ./randall -i /dev/urandom -o 1024 133562368 > /dev/null

real	0m1.410s
user	0m0.447s
sys	0m0.955s
