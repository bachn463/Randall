----------------------------------------------------------------------------------------------------
- In the Makefile, under submission-tarball and randall, we add *.c and *.h to make sure our
compilation links correctly
- Make the necessary .c and paired .h files of the following files:
these files, when made, simply take some methods and includes from randall.c. .c has the
implmentation, .h has the prototypes. When we modularize all these functions, remove the static
keyword.
- cpu; where we pu the cpuid.h include and all matching cpu structs and methods
- rand64-sw; where we put all software methods under the comment header and add matching includes
- In rand64-sw.c, in the places where we call abort();, we can replace them with stderr error
messages using fprintf and exiting our program with status 1.
- rand64-hw; where we put all hardware methods under the comment header and add matching includes
- mrand; implement init, normal, and fini methods using drand (read up on it)
- implement a checkArguments function in options.c and its protoypes and argument struct in .h:
loop through every argument and check if the arg flags are -i or -o or something else(error).
You then loop through the aguments and check if they're properly formatted in their options, like
-i *input* or -o *output*. If everything's good or our -o Nbytes is 0, we can return properly.
This is mostly pulled from the first half of the main function in randall.c. The argument parsing
is done using getopt().
- make mrand.c/h files to deal with the mrand64_r option of input. rdrand and the filepath will be
handled within main itself. 
- Now, we actually implement the rest of main in randall. We basically use our checkArgs function
to see what the input and out of the current options are and parse them as cstrings. We use strcmp
to handle this. if output is rdrand, point the given func pointers to hardware. If its mrand48_r,
we use the mrand48 functions from mrand. If its a filepath starting with '/', use software.
From there, the dealings with the randomization are handled in the given modularized functions
within the *rand* files, so we just have to process the output. We use output.h's functions to
do this:
- writebytes and tostdout are already given in the main function, we just copy and paste them and
go on to write writeToN, which actually allocates a memory buffer for the randomized integers
generated by the rand64 func pointer that we pass through. We basically just loop through the
allocated buffer for every sized unsigned long long and copy the memory of the randomly generated
bytes to the buffer, one by one until we hit some desired length given by the -o flag. We also
have to write this allocated buffer to stdout. Of course, free the allocated memory for every
iteration. Later note: I didn't see we needed to use write(), but use that to find out how many
bytes were actually written and to actually write it to stdout.
- going back to main in randall, we basically just initialize our random generating medium, then
check to see if our output is to stdio or not. we also check the option to the -o flag to see if
we are given a positive integer or not. If everything's valid, then we use our output.c functions
and return. 
- Since everything was done in emacs, I had way too many typos(definitely some in this file) and
some missing includes so I'd probably run make just to see what kind of errors there were.
- Fix an error where getopt() permutes the order of argv, so when we try to parse where nbytes is
in the arguments, there is an error. We just move the nbytes checking before we call getopt. You
could also make a copy of argv before you call getopt and use that to parse for nbytes, but
moving the chunks works fine.
- Fix an error where getopt returns -1 and I check it incorrectly in the while loop so it
incorrectly parses the -i option when -i is the first option before -o. Also, I forgot the : at
the end of the optstring in getopt so sometimes the -o option would return a null argument. 


Below are some time testing benchmarks:

time dd if=/dev/urandom ibs=8192 obs=8192 count=16384 >/dev/null

16384+0 records in
16384+0 records out
134217728 bytes (134 MB, 128 MiB) copied, 0.903535 s, 149 MB/s

real	0m0.908s
user	0m0.015s
sys	0m0.888s

time ./randall -i /dev/urandom 133562368 | cat >/dev/null

real	0m4.069s
user	0m3.999s
sys	0m0.241s

time ./randall 133562368 >/dev/null

real	0m4.256s
user	0m4.114s
sys	0m0.071s

time ./randall 133562368 >rand.data

real	0m5.851s
user	0m4.134s
sys	0m0.110s

time ./randall -i /dev/urandom -o 133562369 133562368 > /dev/null

real	0m1.373s
user	0m0.396s
sys	0m0.951s

time ./randall -i /dev/urandom -o 1024 133562368 > /dev/null

real	0m1.410s
user	0m0.447s
sys	0m0.955s

time ./randall -o stdio -i /dev/urandom 133562368 >/dev/null

real	0m3.050s
user	0m1.705s
sys	0m1.109s

time ./randall -o stdio -i mrand48_r 133562368 >/dev/null

real	0m1.853s
user	0m1.686s
sys	0m0.096s

time ./randall -o stdio -i rdrand 133562368 >/dev/null

real	0m4.606s
user	0m3.699s
sys	0m0.493s

time ./randall -o 100 -i mrand48_r 133562368 >/dev/null

real	0m1.567s
user	0m0.982s
sys	0m0.488s

time ./randall -o 10 -i mrand48_r 133562368 >/dev/null

real	0m10.385s
user	0m6.213s
sys	0m4.024s

time ./randall -o 2 -i mrand48_r 133562368 >/dev/null

real	0m51.482s
user	0m26.663s
sys	0m21.474s
