Bach Ngo Assignment 5

- In the Makefile, under submission-tarball and randall, we add *.c and *.h to make sure our compilation links correctly
- Make the necessary .c and paired .h files of the following files:
these files, when made, simply take some methods and includes from randall.c. .c has the implmentation, .h has the prototypes. When we modularize all these functions, remove the static keyword.
- cpu; where we pu the cpuid.h include and all matching cpu structs and methods
- rand64-sw; where we put all software methods under the comment header and add matching includes
- In rand64-sw.c, in the places where we call abort();, we can replace them with stderr error messages using fprintf and exiting our program with status 1.
- rand64-hw; where we put all hardware methods under the comment header and add matching includes
- mrand; implement init, normal, and fini methods using drand (read up on it)
- implement a checkArguments function in options.c and its protoypes and argument struct in .h: loop through every argument and check if the arg flags are -i or -o or something else(error). You then loop through the aguments and check if they're properly formatted in their options, like -i *input* or -o *output*. If everything's good or our -o Nbytes is 0, we can return properly. This is mostly pulled from the first half of the main function in randall.c. The argument parsing is done using getopt().
- make mrand.c/h files to deal with the mrand64_r option of input. rdrand and the filepath will be handled within main itself. 
- Now, we actually implement the rest of main in randall. We basically use our checkArgs function to see what the input and out of the current options are and parse them as cstrings. We use strcmp to handle this. if output is rdrand, point the given func pointers to hardware. If its mrand48_r, we use the mrand48 functions from mrand. If its a filepath starting with '/', use software. From there, the dealings with the randomization are handled in the given modularized functions within the *rand* files, so we just have to process the output. We use output.h's functions to do this:
- writebytes and tostdout are already given in the main function, we just copy and paste them and go on to write writeToN, which actually allocates a memory buffer for the randomized integers generated by the rand64 func pointer that we pass through. We basically just loop through the allocated buffer for every sized unsigned long long and copy the memory of the randomly generated bytes to the buffer, one by one until we hit some desired length given by the -o flag. We also have to write this allocated buffer to stdout. Of course, free the allocated memory for every iteration.
- going back to main in randall, we basically just initialize our random generating medium, then check to see if our output is to stdio or not. we also check the option to the -o flag to see if we are given a positive integer or not. If everything's valid, then we use our output.c functions and return. 
